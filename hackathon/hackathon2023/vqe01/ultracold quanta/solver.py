import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input-mol", help="input molecular data", type=str, default="h4.csv")
parser.add_argument("-x", "--output-mol", help="output molecular data", type=str, default="h4_best.csv")
args = parser.parse_args()

# Your solution is below
# Example:
import numpy as np
from openfermion.chem import MolecularData
from openfermionpyscf import run_pyscf
from mindquantum.core.operators import InteractionOperator
from mindquantum.algorithm.nisq import uccsd_singlet_generator
from mindquantum.core.circuit import Circuit
from mindquantum.core.operators import FermionOperator
from qupack.vqe import ESConserveHam, ExpmPQRSFermionGate, ESConservation
from mindquantum.simulator import Simulator
from mindquantum.core.operators import Hamiltonian
from mindquantum.algorithm.nisq import generate_uccsd
from scipy.optimize import minimize
from collections import OrderedDict as ordict
import itertools
from mindquantum.core import FermionOperator,QubitOperator
from mindquantum.core import down_index, up_index, normal_ordered
from mindquantum.algorithm import Transform
from mindquantum.third_party.interaction_operator import InteractionOperator
from mindquantum.core import RX, H, X, RZ, RY
from mindquantum.core import Circuit, TimeEvolution
from mindquantum.core import ParameterResolver as PR
from mindquantum.algorithm.nisq import uccsd_singlet_generator
from mindquantum.core import UN
from scipy.optimize import minimize
import time

def read_csv(file_name):
    with open(file_name, 'r') as f:
        data = f.readlines()
    mol_name = []
    mol_poi = []
    for i in data:
        tmp = i.split(',')
        mol_name.append(tmp[0])
        mol_poi.extend([float(i) for i in tmp[1:]])
    return mol_name, np.array(mol_poi)


def gene_uccsd(mol):
    geometry = mol[1].reshape(len(mol[0]), -1)
    geometry = [[mol[0][i], list(j)] for i, j in enumerate(geometry)]
    basis = "sto3g"
    molecule_of = MolecularData(geometry, basis, multiplicity=1, data_directory='./')
    mol = run_pyscf(
        molecule_of,
        run_fci=1,
    )
    # 构建k-uccgsd ansatz电路
    def upccgsd_generator_circuit(mol, k=1, anti_hermitian=True):  # pylint: disable=too-many-locals,too-many-statements
        """
        Generate a uccsd quantum circuit.

        Args:
            mol (molecular): A hdf5 molecular file generated by HiQ Fermion.
            threshold (float, optional): A threshold of parameters. If the absolute value of parameter is
                lower than the threshold, than we will not update it in VQE
                algorithm. Default: ``0``.
        """
        n_qubits = mol.n_qubits
        n_electrons = mol.n_electrons
        params = {}
        if n_qubits % 2 != 0:
            raise ValueError('The total number of spin-orbitals should be even.')
        single_ops_list = []
        double_ops_list = []
        n_spatial_orbitals = n_qubits // 2

        # Generate excitations
        spin_index_functions = [up_index, down_index]
        # Generate all spin-conserving single and double excitations derived
        # from one spatial occupied-virtual pair
        k_upccgsd_circuit = Circuit()

        for n in range(k):
            single_and_double_ops = FermionOperator()
            op_count = 0
            for i in range(n_spatial_orbitals):
                for a in range(i + 1, n_spatial_orbitals):
                    # Get indices of spatial orbitals
                    virtual_spatial = a
                    occupied_spatial = i

                    for spin in range(2):
                        # Get the functions which map a spatial orbital index to a
                        # spin orbital index
                        this_index = spin_index_functions[spin]
                        other_index = spin_index_functions[1 - spin]

                        # Get indices of spin orbitals
                        virtual_this = this_index(virtual_spatial)
                        virtual_other = other_index(virtual_spatial)
                        occupied_this = this_index(occupied_spatial)
                        occupied_other = other_index(occupied_spatial)

                        # Generate single excitations

                        coeff = PR({'k' + str(n) + f'_s{op_count}': 1})
                        params['k' + str(n) + f'_s{op_count}'] = 0.0

                        fermion_ops = FermionOperator(
                            ((occupied_this, 1), (virtual_this, 0)), coeff)

                        if anti_hermitian:
                            fermion_ops += FermionOperator(
                                ((virtual_this, 1), (occupied_this, 0)), -1 * coeff)

                        fermion_ops = normal_ordered(fermion_ops)
                        single_and_double_ops += fermion_ops

                        if n == 0 and fermion_ops not in single_ops_list:
                            single_ops_list.append(fermion_ops)

                        # Generate double excitation
                        coeff = PR({'k' + str(n) + f'_d{op_count}': 1})
                        params['k' + str(n) + f'_d{op_count}'] = 0.0

                        fermion_ops = FermionOperator(
                            ((virtual_this, 1), (occupied_this, 0), (virtual_other, 1),
                            (occupied_other, 0)), coeff)
                        if anti_hermitian:
                            fermion_ops += FermionOperator(
                                ((occupied_other, 1), (virtual_other, 0),
                                (occupied_this, 1), (virtual_this, 0)), -1 * coeff)

                        fermion_ops = normal_ordered(fermion_ops)
                        single_and_double_ops += fermion_ops

                        if n == 0 and fermion_ops not in double_ops_list:
                            double_ops_list.append(fermion_ops)

                    op_count += 1
            single_and_double_ops = normal_ordered(single_and_double_ops)
            # single_and_double_qubit_ops = Transform(single_and_double_ops).jordan_wigner()
            # k_upccgsd_circuit += TimeEvolution(single_and_double_qubit_ops.imag, 1.0).circuit
            for term in single_and_double_ops:
                k_upccgsd_circuit += ExpmPQRSFermionGate(term)

        single_and_double_ops_list = single_ops_list + double_ops_list

        return params, k_upccgsd_circuit
    def _transform2pauli(fermion_ansatz):
        """Transform a fermion ansatz to pauli ansatz based on jordan-wigner transformation."""
        out = ordict()
        for i in fermion_ansatz:
            qubit_generator = Transform(i[0]).jordan_wigner()
            if qubit_generator.terms:
                for key, term in qubit_generator.terms.items():
                    if key not in out:
                        out[key] = ordict({i[1]: float(term.imag)})
                    else:
                        if i[1] in out[key]:
                            out[key][i[1]] += float(term.imag)
                        else:
                            out[key][i[1]] = float(term.imag)
        return out
    def _pauli2circuit(pauli_ansatz):
        """Transform a pauli ansatz to parameterized quantum circuit."""
        circuit = Circuit()
        for k, v in pauli_ansatz.items():
            circuit += decompose_single_term_time_evolution(k, v)
        return circuit

    def decompose_single_term_time_evolution(term, para):
        """
        Decompose a time evolution gate into basic quantum gates.

        This function only work for the hamiltonian with only single pauli word.
        For example, exp(-i * t * ham), ham can only be a single pauli word, such
        as ham = X0 x Y1 x Z2, and at this time, term will be
        ((0, 'X'), (1, 'Y'), (2, 'Z')). When the evolution time is expressd as
        t = a*x + b*y, para would be {'x':a, 'y':b}.

        Args:
            term (tuple, QubitOperator): the hamiltonian term of just the
                evolution qubit operator.
            para (dict): the parameters of evolution operator.

        Returns:
            Circuit, a quantum circuit.
        """
        if not isinstance(term, tuple):
            try:
                if len(term.terms) != 1:
                    raise ValueError("Only work for single term time \
                            evolution operator, but get {}".format(len(term)))
                term = list(term.terms.keys())[0]
            except TypeError:
                raise Exception("Not supported type:{}".format(type(term)))

        out = []
        term = sorted(term)
        rxs = []
        if len(term) == 1:  # single pauli operator
            if term[0][1] == 'X':
                out.append(RX(para).on(term[0][0]))
            elif term[0][1] == 'Y':
                out.append(RY(para).on(term[0][0]))
            else:
                out.append(RZ(para).on(term[0][0]))
        else:
            for index, action in term:
                if action == 'X':
                    out.append(H.on(index))
                elif action == 'Y':
                    rxs.append(len(out))
                    out.append(RX(np.pi / 2).on(index))

            for i in range(len(term) - 1):
                out.append(X.on(term[i + 1][0], term[i][0]))
            out.append(RZ({i: 2 * j for i, j in para.items()}).on(term[-1][0]))
            for i in range(len(out) - 1)[::-1]:
                if i in rxs:
                    out.append(RX(np.pi * 3.5).on(out[i].obj_qubits))
                else:
                    out.append(out[i])
        return Circuit(out)

    def generate_upccgsd(molecular, k=1):
        if isinstance(molecular, str):
            mol = MolecularData(filename=molecular)
            mol.load()
        else:
            mol = molecular
        parameters, k_upccgsd_circuit = upccgsd_generator_circuit(mol, k)

        ham_of = mol.get_molecular_hamiltonian()
        inter_ops = InteractionOperator(*ham_of.n_body_tensors.values())
        ham_hiq = FermionOperator(inter_ops)
        # qubit_hamiltonian = Transform(ham_hiq).jordan_wigner()
        # qubit_hamiltonian.compress()
        ham_fo = normal_ordered(ham_hiq).real
        qubit_hamiltonian = ESConserveHam(ham_fo)

        parameters_name = list(parameters.keys())
        return k_upccgsd_circuit, \
            parameters_name, \
            qubit_hamiltonian, \
            mol.n_qubits, \
            mol.n_electrons
    
    # ham = mol.get_molecular_hamiltonian()
    # inter_ops = InteractionOperator(*ham.n_body_tensors.values())
    # ham_hiq = FermionOperator(inter_ops)
    # ham_qo = Transform(ham_hiq).jordan_wigner()
    # 创建ansatz电路
    k_upccgsd_circuit,_,ham_qo,_,_ = generate_upccgsd(mol,k=2)

    return ham_qo, k_upccgsd_circuit, mol.n_qubits, mol.n_electrons


def run_uccsd(ham, circ, nq, ne):
    # sim = Simulator('mqvector',nq)
    sim = ESConservation(nq, ne)
    grad_ops = sim.get_expectation_with_grad(ham, circ)

    def fun(p0, grad_ops):
        f, g = grad_ops(p0)
        return f.real, g.real

    p0 = np.zeros(len(circ.params_name))+1e-6

    res = minimize(fun, p0, args=(grad_ops, ), jac=True, method='bfgs')
    return res.fun

def opti_geo(geo, mol_name):
    ham, circ, nq, ne = gene_uccsd([mol_name, geo])
    res = run_uccsd(ham, circ, nq, ne)
    #print(res,'\t', time.ctime())
    best_x = geo.reshape(len(mol_name), -1)
    out = []
    for idx, n in enumerate(mol_name):
        tmp = [n]
        tmp.extend([str(i) for i in best_x[idx]])
        out.append(', '.join(tmp) + '\n')

    with open(args.output_mol, 'w') as f:
        f.writelines(out)

    return res

name, p0 = read_csv(args.input_mol)
p0=np.random.uniform(size=len(p0))
res = minimize(opti_geo, p0, args=(name, ), method='BFGS')
best_x = res.x.reshape(len(name), -1)
out = []
for idx, n in enumerate(name):
    tmp = [n]
    tmp.extend([str(i) for i in best_x[idx]])
    out.append(', '.join(tmp) + '\n')

with open(args.output_mol, 'w') as f:
    f.writelines(out)
