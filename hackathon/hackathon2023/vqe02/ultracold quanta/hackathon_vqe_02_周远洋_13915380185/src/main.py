# Example program. (No meaningful result)
# The judging program "eval.py" will call `Main.run()` function from "src/main.py",
# and receive an energy value. So please put the executing part of your algorithm
# in `Main.run()`, return an energy value.
# All of your code should be placed in "src/" folder.

import numpy as np
from mindquantum.core.circuit import Circuit
from mindquantum.simulator import Simulator
from mindquantum.core.operators import Hamiltonian
from mindquantum.algorithm.nisq import generate_uccsd
from scipy.optimize import minimize
from openfermion.chem import MolecularData
# from openfermionpyscf import run_pyscf
from collections import OrderedDict as ordict
import itertools
from mindquantum.core import FermionOperator,QubitOperator
from mindquantum.core import down_index, up_index, normal_ordered
from mindquantum.algorithm import Transform
from mindquantum.third_party.interaction_operator import InteractionOperator
from mindquantum.core import RX, H, X, RZ, RY
from mindquantum.core import Circuit, TimeEvolution
from mindquantum.core import ParameterResolver as PR
from mindquantum.algorithm.nisq import uccsd_singlet_generator
from mindquantum.core import UN



def excited_state_solver(mol):
    # 构建k-uccgsd ansatz电路
    def upccgsd_generator_circuit(mol, k=1, anti_hermitian=True):  # pylint: disable=too-many-locals,too-many-statements
        """
        Generate a uccsd quantum circuit.

        Args:
            mol (molecular): A hdf5 molecular file generated by HiQ Fermion.
            threshold (float, optional): A threshold of parameters. If the absolute value of parameter is
                lower than the threshold, than we will not update it in VQE
                algorithm. Default: ``0``.
        """
        n_qubits = mol.n_qubits
        n_electrons = mol.n_electrons
        params = {}
        if n_qubits % 2 != 0:
            raise ValueError('The total number of spin-orbitals should be even.')
        single_ops_list = []
        double_ops_list = []
        n_spatial_orbitals = n_qubits // 2

        # Generate excitations
        spin_index_functions = [up_index, down_index]
        # Generate all spin-conserving single and double excitations derived
        # from one spatial occupied-virtual pair
        k_upccgsd_circuit = Circuit()

        for n in range(k):
            single_and_double_ops = FermionOperator()
            op_count = 0
            for i in range(n_spatial_orbitals):
                for a in range(i + 1, n_spatial_orbitals):
                    # Get indices of spatial orbitals
                    virtual_spatial = a
                    occupied_spatial = i

                    for spin in range(2):
                        # Get the functions which map a spatial orbital index to a
                        # spin orbital index
                        this_index = spin_index_functions[spin]
                        other_index = spin_index_functions[1 - spin]

                        # Get indices of spin orbitals
                        virtual_this = this_index(virtual_spatial)
                        virtual_other = other_index(virtual_spatial)
                        occupied_this = this_index(occupied_spatial)
                        occupied_other = other_index(occupied_spatial)

                        # Generate single excitations

                        coeff = PR({'k' + str(n) + f'_s{op_count}': 1})
                        params['k' + str(n) + f'_s{op_count}'] = 0.0

                        fermion_ops = FermionOperator(
                            ((occupied_this, 1), (virtual_this, 0)), coeff)

                        if anti_hermitian:
                            fermion_ops += FermionOperator(
                                ((virtual_this, 1), (occupied_this, 0)), -1 * coeff)

                        fermion_ops = normal_ordered(fermion_ops)
                        single_and_double_ops += fermion_ops

                        if n == 0 and fermion_ops not in single_ops_list:
                            single_ops_list.append(fermion_ops)

                        # Generate double excitation
                        coeff = PR({'k' + str(n) + f'_d{op_count}': 1})
                        params['k' + str(n) + f'_d{op_count}'] = 0.0

                        fermion_ops = FermionOperator(
                            ((virtual_this, 1), (occupied_this, 0), (virtual_other, 1),
                            (occupied_other, 0)), coeff)
                        if anti_hermitian:
                            fermion_ops += FermionOperator(
                                ((occupied_other, 1), (virtual_other, 0),
                                (occupied_this, 1), (virtual_this, 0)), -1 * coeff)

                        fermion_ops = normal_ordered(fermion_ops)
                        single_and_double_ops += fermion_ops

                        if n == 0 and fermion_ops not in double_ops_list:
                            double_ops_list.append(fermion_ops)

                    op_count += 1
            single_and_double_ops = normal_ordered(single_and_double_ops)
            single_and_double_qubit_ops = Transform(single_and_double_ops).jordan_wigner()
            k_upccgsd_circuit += TimeEvolution(single_and_double_qubit_ops.imag, 1.0).circuit

        single_and_double_ops_list = single_ops_list + double_ops_list

        return params, k_upccgsd_circuit


    def _transform2pauli(fermion_ansatz):
        """Transform a fermion ansatz to pauli ansatz based on jordan-wigner transformation."""
        out = ordict()
        for i in fermion_ansatz:
            qubit_generator = Transform(i[0]).jordan_wigner()
            if qubit_generator.terms:
                for key, term in qubit_generator.terms.items():
                    if key not in out:
                        out[key] = ordict({i[1]: float(term.imag)})
                    else:
                        if i[1] in out[key]:
                            out[key][i[1]] += float(term.imag)
                        else:
                            out[key][i[1]] = float(term.imag)
        return out


    def _pauli2circuit(pauli_ansatz):
        """Transform a pauli ansatz to parameterized quantum circuit."""
        circuit = Circuit()
        for k, v in pauli_ansatz.items():
            circuit += decompose_single_term_time_evolution(k, v)
        return circuit

    def decompose_single_term_time_evolution(term, para):
        """
        Decompose a time evolution gate into basic quantum gates.

        This function only work for the hamiltonian with only single pauli word.
        For example, exp(-i * t * ham), ham can only be a single pauli word, such
        as ham = X0 x Y1 x Z2, and at this time, term will be
        ((0, 'X'), (1, 'Y'), (2, 'Z')). When the evolution time is expressd as
        t = a*x + b*y, para would be {'x':a, 'y':b}.

        Args:
            term (tuple, QubitOperator): the hamiltonian term of just the
                evolution qubit operator.
            para (dict): the parameters of evolution operator.

        Returns:
            Circuit, a quantum circuit.
        """
        if not isinstance(term, tuple):
            try:
                if len(term.terms) != 1:
                    raise ValueError("Only work for single term time \
                            evolution operator, but get {}".format(len(term)))
                term = list(term.terms.keys())[0]
            except TypeError:
                raise Exception("Not supported type:{}".format(type(term)))

        out = []
        term = sorted(term)
        rxs = []
        if len(term) == 1:  # single pauli operator
            if term[0][1] == 'X':
                out.append(RX(para).on(term[0][0]))
            elif term[0][1] == 'Y':
                out.append(RY(para).on(term[0][0]))
            else:
                out.append(RZ(para).on(term[0][0]))
        else:
            for index, action in term:
                if action == 'X':
                    out.append(H.on(index))
                elif action == 'Y':
                    rxs.append(len(out))
                    out.append(RX(np.pi / 2).on(index))

            for i in range(len(term) - 1):
                out.append(X.on(term[i + 1][0], term[i][0]))
            out.append(RZ({i: 2 * j for i, j in para.items()}).on(term[-1][0]))
            for i in range(len(out) - 1)[::-1]:
                if i in rxs:
                    out.append(RX(np.pi * 3.5).on(out[i].obj_qubits))
                else:
                    out.append(out[i])
        return Circuit(out)

    def generate_upccgsd(molecular, k=1):
        if isinstance(molecular, str):
            mol = MolecularData(filename=molecular)
            mol.load()
        else:
            mol = molecular
        parameters, k_upccgsd_circuit = upccgsd_generator_circuit(mol, k)

        ham_of = mol.get_molecular_hamiltonian()
        inter_ops = InteractionOperator(*ham_of.n_body_tensors.values())
        ham_hiq = FermionOperator(inter_ops)
        qubit_hamiltonian = Transform(ham_hiq).jordan_wigner()
        qubit_hamiltonian.compress()

        parameters_name = list(parameters.keys())
        return k_upccgsd_circuit, \
            parameters_name, \
            qubit_hamiltonian, \
            mol.n_qubits, \
            mol.n_electrons
    ucc_fermion_ops = uccsd_singlet_generator(mol.n_qubits,mol.n_electrons,anti_hermitian=True)

    # 但是该算子无法直接运用到量子计算机上，所以用JW进行变换
    # 该函数返回QubitOperqtor算子
    ucc_qubits_ops = Transform(ucc_fermion_ops).jordan_wigner()

    # 需要注意的是，TimeEvolution可生成exp(-iHt)的演化算子所对应的线路，由于ucc_qubits_ops中包含了复数因子i
    hf_circ = Circuit()
    hf_circ += UN(X,mol.n_electrons)
    u0_circ = Circuit()
    u0_circ +=TimeEvolution(ucc_qubits_ops.imag).circuit
    # k_upccgsd_circuit,_,_,_,_ = generate_upccgsd(mol,k=2)

    ham = mol.get_molecular_hamiltonian()
    # 转换为相互作用算子
    inter_ops = InteractionOperator(*ham.n_body_tensors.values())
    # 转换为费米算子
    ham_hiq = FermionOperator(inter_ops)
    # 将费米算子通过JW变换到可以在量子计算机上运行的算子
    ham_qo = Transform(ham_hiq).jordan_wigner()

    # 创建模拟器
    sim = Simulator('mqvector',mol.n_qubits)
    # 梯度算子为
    # 用hamiltonian算子将QubitOperator算子包装起来
    grad_ops = sim.get_expectation_with_grad(Hamiltonian(ham_qo),hf_circ+u0_circ)
    init_amp = np.zeros(len(u0_circ.params_name))+1e-6

    def func(amp,grad_ops):
        f,g = grad_ops(amp)
        f = np.real(f)[0,0]
        g = np.real(g)[0,0]
        return f,g

    res = minimize(func,init_amp,args=(grad_ops,),method='bfgs',jac=True)
    # print('ground energy:',res.fun)

    gs_pr = dict(zip(u0_circ.params_name,res.x))
    u0_circ = u0_circ.apply_value(gs_pr)

    # 构建辅助比特线路
    n_aux_qubits = 1
    aux_circuit = Circuit()
    aux_circuit += Circuit([X.on(i) for i in range(mol.n_electrons,mol.n_qubits)])
    aux_circuit += X.on(mol.n_qubits,ctrl_qubits=[i for i in range(0,mol.n_qubits)])
    aux_circuit += Circuit([X.on(i) for i in range(mol.n_electrons,mol.n_qubits)])

    # 构建u_1 ansatz电路，现在u_0电路不含参数
    # 利用k-uccgsd线路
    u1_circuit,_,_,_,_ = generate_upccgsd(mol,k=1)

    total_circ = hf_circ+u1_circuit+aux_circuit+u0_circ

    aux_hamiltonian_QubitOperator = 0.5*QubitOperator('I{}'.format(mol.n_qubits))+0.5*QubitOperator('Z{}'.format(mol.n_qubits))
    eff_hamiltonian_qubitOperator = aux_hamiltonian_QubitOperator * ham_qo

    sim1 = Simulator('mqvector',mol.n_qubits+n_aux_qubits)
    es_grad_ops = sim1.get_expectation_with_grad(Hamiltonian(eff_hamiltonian_qubitOperator),total_circ)
    init_amp1 = np.zeros(len(u1_circuit.params_name))+1e-6

    def excited_energy(amp,grad_ops):
        f, g = grad_ops(amp)
        f = np.real(f)[0, 0]
        g = np.real(g)[0, 0]
        return f, g

    es_res = minimize(excited_energy,init_amp1,args=(es_grad_ops,),method='bfgs',jac=True)
    # print('excited energy:',es_res.fun)
    return es_res.fun

class Main:
    def run(self, mol):
        return excited_state_solver(mol)
