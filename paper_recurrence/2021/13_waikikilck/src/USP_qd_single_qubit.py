# -*- coding: utf-8 -*-
"""
Created on Tue Dec 28 03:07:02 2021
用于半导体双量子点量子模型
单量子比特任意态之间的相互制备

动作选用三种策略：

先采用第一种：要么最优，要么选次优

如果效果不好就选第二种：动作要么选最优的，要么选最差的

如果都达不到保真度阈值，就再试试始终选最优的

最后那种策略在全过程中达到的最大保真度最高，就选用那个策略

@author: Waikikilick
email: 1250125907@qq.com

"""

from mindquantum import *
import matplotlib.pyplot as plt
from scipy.linalg import expm
from time import *
import numpy as np

np.random.seed(1)  # 设置随机数种子，使算法表现稳定

T = 2 * np.pi  # 最大演化时间
dt = np.pi / 5  # 时间步长
step_max = T / dt  # 最大控制脉冲数

sx = X.matrix().astype(
    np.complex128)  # 定义泡利算符，根据 mindquantum 基本门的 matrix() 功能来得到矩阵形式
sy = Y.matrix().astype(np.complex128)
sz = Z.matrix().astype(np.complex128)
si = I.matrix().astype(np.complex128)

action_space = np.array([[0], [1], [2], [3]])  # 离散动作空间

#---------------------------------------------------------------------------------------------------
theta_num = 6  # 除了 0 和 Pi 两个点之外，点的数量
varphi_num = 21  # varphi 角度一圈上的点数
#总点数为 theta_num * varphi_num + 2(布洛赫球两极) 此处共 128 个点

theta = np.linspace(0, np.pi, theta_num + 2, endpoint=True)
varphi = np.linspace(0, np.pi * 2, varphi_num, endpoint=False)


def psi_set():
    psi_set = []
    for ii in range(1, theta_num + 1):
        for jj in range(varphi_num):
            psi_set.append(
                np.array([
                    np.cos(theta[ii] / 2),
                    np.sin(theta[ii] / 2) *
                    (np.cos(varphi[jj]) + np.sin(varphi[jj]) * (0 + 1j))
                ]))

    psi_set.append(np.array([1, 0]))  # 最后再加上 |0> 和 |1> 两个态
    psi_set.append(np.array([0, 1]))
    return psi_set


target_set = psi_set()  # 目标量子态集
init_set = psi_set()  # 初始量子态集


#----------------------------------------------------------------------------------------------------
def _matrix(coeff):
    f = np.sqrt(1 + coeff**2)
    theta = f * dt
    return np.cos(theta) * si - 1j * np.sin(theta) * (coeff / f * sz +
                                                      1 / f * sx)


def _diff_matrix(coeff):
    f = np.sqrt(1 + coeff**2)
    theta = f * dt
    m = np.cos(theta) * si - 1j * np.sin(theta) * (coeff / f * sz + 1 / f * sx)
    return -1j * dt * m @ sz


Evo = gene_univ_parameterized_gate('U', _matrix, _diff_matrix)  # 给定动作的时间演化算符
circ = Circuit() + Evo('coeff').on(0)  # 将时间演化算符作为量子门编到线路中
circ = circ.as_encoder()
ham = Hamiltonian(QubitOperator(""))  # 定义一个空的哈密顿量，用于后面求解两个量子态之间的保真度


#------------------------------------------------------------------------------------------------------------------------
# 动作选择策略 0：选择下一时刻量子态保真度更高所对应的那个动作
def step0(sim, sim_target, F):  # 这里 F 就没啥用了，只是为了和其他两种策略比齐
    fid_ops = sim.get_expectation_with_grad(
        ham,  # 单位算符，除了占位，啥用也没有。因为要计算的是两个量子态之间的保真度
        circ,  # 右线路，由时间演化算符所定义。用于根据当前时刻量子态计算下一时刻量子态
        Circuit(),  # 左线路，空的。保持目标态不变
        sim_target,  # 目标量子态
        parallel_worker=1)  # 并行核

    fid_list, _ = fid_ops(
        action_space)  # np.array([[0],[1],[2],[3]]) 每一行作为一个样本
    fid_list = np.squeeze(np.abs(fid_list)**2)

    best_action = np.argmax(fid_list)
    best_fid = fid_list[best_action]

    sim.apply_circuit(circ, pr=best_action)
    psi_ = sim.get_qs()

    return best_action, best_fid, psi_


#------------------------------------------------------------------------------------------------------------------------
# 动作选择策略 1：要么选最优动作，要么选最差的动作
def step1(sim, sim_target,
          F):  # F 作为判断控制是否陷入局部最优，如果各动作中没有比 F 更高的保真度，就意味着陷入了局部最优
    fid_ops = sim.get_expectation_with_grad(
        ham,  # 单位算符，除了占位，啥用也没有。因为要计算的是两个量子态之间的保真度
        circ,  # 右线路，由时间演化算符所定义。用于根据当前时刻量子态计算下一时刻量子态
        Circuit(),  # 左线路，空的。保持目标态不变
        sim_target,  # 目标量子态
        parallel_worker=1)  # 并行核
    _ = fid_ops(np.array([0.0])) # warm up
    fid_list, _ = fid_ops(
        action_space)  # np.array([[0],[1],[2],[3]]) 每一行作为一个样本
    fid_list = np.squeeze(np.abs(fid_list)**2)

    if F < max(fid_list):  # 如果没有陷入局部最优，就直接选择最大保真度对应的动作
        best_action = np.argmax(fid_list)
        best_fid = fid_list[best_action]

    else:  # 否则选择最差的动作，以最大程度跳出局部最优
        best_action = np.argmin(fid_list)
        best_fid = fid_list[best_action]

    sim.apply_circuit(circ, pr=best_action)
    psi_ = sim.get_qs()

    return best_action, best_fid, psi_


#------------------------------------------------------------------------------------------------------------------------
# 动作选择策略 2：要么选最优动作，要么选次优的动作
def step2(sim, sim_target,
          F):  # F 作为判断控制是否陷入局部最优，如果各动作中没有比 F 更高的保真度，就意味着陷入了局部最优
    fid_ops = sim.get_expectation_with_grad(
        ham,  # 单位算符，除了占位，啥用也没有。因为要计算的是两个量子态之间的保真度
        circ,  # 右线路，由时间演化算符所定义。用于根据当前时刻量子态计算下一时刻量子态
        Circuit(),  # 左线路，空的。保持目标态不变
        sim_target,  # 目标量子态
        parallel_worker=1)  # 并行核

    fid_list, _ = fid_ops(
        action_space)  # np.array([[0],[1],[2],[3]]) 每一行作为一个样本
    fid_list = np.squeeze(np.abs(fid_list)**2)

    if F < max(fid_list):  # 如果没有陷入局部最优，就直接选择最大保真度对应的动作
        best_action = np.argmax(fid_list)
        best_fid = fid_list[best_action]

    else:  # 否则选择最差的动作，以最小代价跳出局部最优
        fid_list[np.argmax(fid_list)] = 0  # 将最大保真度故意赋值为 0
        best_action = np.argmax(fid_list)  # 那么再对保真度列表求一次最大值，就是实际上的次最大值了
        best_fid = fid_list[best_action]

    sim.apply_circuit(circ, pr=best_action)
    psi_ = sim.get_qs()

    return best_action, best_fid, psi_


#--------------------------------------------------------------------------------
def job(target_set):  # 输入为一个128个采样点的目标态集合。
    # 每个目标态target_psi都由初始态集中的初态制备

    F_list = []  # 用于记录制备所有目标态的平均保真度
    count = 0  # 用于监测程序执行进度，达到128时即完成

    sim = Simulator('mqvector', 1)
    sim_target = Simulator('mqvector', 1)

    for target_psi in target_set:
        print(count)
        count += 1

        sim_target.set_qs(target_psi)  # 设置目标量子态
        fids_list = []  # 用于记录所有初始态制备本目标态中目标态的保真度

        for psi1 in init_set:  # 对初始态集合中的每个初始态进行遍历执行

            sim.set_qs(psi1)  # 设置当前时刻量子态
            fid_ops = sim.get_expectation_with_grad(
                ham,  # 单位算符，除了占位，啥用也没有。因为要计算的是两个量子态之间的保真度
                Circuit(),  # 右线路，空的。保持当前量子态不变
                Circuit(),  # 左线路，空的。保持目标态不变
                sim_target)  # 目标量子态
            fid, _ = fid_ops(np.array([]))  # 调用函数
            F = np.squeeze(
                (np.abs(fid)**2))  # 先计算一下初始态的保真度，以便与下一时刻的保真度进行比较，以判断是否陷入局部最优

            fid_max = F  # 每个策略分开执行
            fid_max1 = F
            fid_max2 = F
            fid_max0 = F

            # 执行策略 1：选 最佳动作 或 次优动作
            step_n = 0  # 计算控制脉冲数
            while True:
                action, F, psi_ = step1(sim, sim_target,
                                        F)  # 采用策略 1 来确定动作、下一时刻的保真度 和 下一时刻量子态
                fid_max1 = max(F, fid_max1)  # 记录此策略下能达到的最大保真度，用于判定效果和截取控制脉冲序列。
                psi = psi_  # 迭代量子态
                step_n += 1
                if fid_max1 > 0.999 or step_n > step_max:  # 当保真度大于阈值0.999或总步数超过限制就终止循环
                    break

            # 与上面类似的操作，执行的是策略 2：选最佳动作 或 最差动作
            step_n = 0
            sim.set_qs(psi1)  # 设置当前时刻量子态
            fid_ops = sim.get_expectation_with_grad(ham, Circuit(), Circuit(),
                                                    sim_target)
            fid, _ = fid_ops(np.array([]))  # 调用函数
            F = np.squeeze(
                (np.abs(fid)**2))  # 先计算一下初始态的保真度，以便与下一时刻的保真度进行比较，以判断是否陷入局部最优

            while True:
                action, F, psi_ = step2(sim, sim_target, F)
                fid_max2 = max(F, fid_max2)
                psi = psi_
                step_n += 1
                if fid_max2 > 0.999 or step_n > step_max:
                    break

            # 与上面类似的操作，执行的是策略 0：只选选最佳动作
            step_n = 0
            sim.set_qs(psi1)  # 设置当前时刻量子态
            fid_ops = sim.get_expectation_with_grad(ham, Circuit(), Circuit(),
                                                    sim_target)
            fid, _ = fid_ops(np.array([]))  # 调用函数
            F = np.squeeze(
                (np.abs(fid)**2))  # 先计算一下初始态的保真度，以便与下一时刻的保真度进行比较，以判断是否陷入局部最优
            while True:
                action, F, psi_ = step0(sim, sim_target, F)
                fid_max0 = max(F, fid_max0)
                psi = psi_
                step_n += 1
                if fid_max0 > 0.999 or step_n > step_max:
                    break

            fid_max = max(fid_max1, fid_max2, fid_max0)  # 能达到最大保真度的策略即为最佳策略
            fids_list.append(fid_max)  # 将这个初始态能达到的最大保真度记录下来
        F_list.append(np.mean(fids_list))

    return F_list  # 返回所有态制备任务的平均保真度


#-------------------------------------------------------------------------------------------
if __name__ == '__main__':

    time1 = time()

    F_list = job(target_set)  # 执行函数 得到记录着目标态态制备任务的各自保真度的列表

    time2 = time()
    print('time_cost is: ', time2 - time1)  # 得到程序运行的总时间
    print('mean of the F_list is: ', np.mean(F_list))
    print('F_list = ', F_list)

    # 对数据进行处理，画出热图
    F_0 = F_list[-2]
    F_1 = F_list[-1]

    del F_list[-1]
    del F_list[-1]

    F_0_list = []
    F_1_list = []

    for _ in range(varphi_num):
        F_0_list.append(F_0)

    for _ in range(varphi_num):
        F_1_list.append(F_1)

    F_list_plot = F_0_list + F_list + F_1_list
    F_array_plot = np.array(F_list_plot)
    F_array_plot = F_array_plot.reshape((theta_num + 2, varphi_num))

    plt.figure(figsize=(12, 12))
    plt.title(
        r'State Preparing Fidelity Heat-map in Single-qubit $S-T_0$ DQDs')
    plt.xlabel(r'$\varphi/\pi$')
    plt.xticks(ticks=[0, 5, 10, 15, 20], labels=[0, 0.5, 1, 1.5, 2])
    plt.ylabel(r'$\theta/\pi$')
    plt.yticks(ticks=[0, 1.4, 2.8, 4.2, 5.6, 7],
               labels=[1.0, 0.8, 0.6, 0.4, 0.2, 0.0])
    plt.imshow(F_array_plot)
    plt.colorbar(shrink=0.32,
                 aspect=10,
                 label=r'$\bar{F}$',
                 ticks=[0.795, 0.836, 0.877, 0.917, 0.958, 0.999])
    plt.show()
    plt.savefig('./src/dq_single_qubit_heat_map.png')

#目标点集
# [matrix([[0.92387953+0.j],
#          [0.38268343+0.j]]),
#  matrix([[0.92387953+0.j        ],
#          [0.27059805+0.27059805j]]),
#  matrix([[9.23879533e-01+0.j        ],
#          [2.34326020e-17+0.38268343j]]),
#  matrix([[ 0.92387953+0.j        ],
#          [-0.27059805+0.27059805j]]),
#  matrix([[ 0.92387953+0.00000000e+00j],
#          [-0.38268343+4.68652041e-17j]]),
#  matrix([[ 0.92387953+0.j        ],
#          [-0.27059805-0.27059805j]]),
#  matrix([[ 9.23879533e-01+0.j        ],
#          [-7.02978061e-17-0.38268343j]]),
#  matrix([[0.92387953+0.j        ],
#          [0.27059805-0.27059805j]]),
#  matrix([[0.70710678+0.j],
#          [0.70710678+0.j]]),
#  matrix([[0.70710678+0.j ],
#          [0.5       +0.5j]]),
#  matrix([[7.07106781e-01+0.j        ],
#          [4.32978028e-17+0.70710678j]]),
#  matrix([[ 0.70710678+0.j ],
#          [-0.5       +0.5j]]),
#  matrix([[ 0.70710678+0.00000000e+00j],
#          [-0.70710678+8.65956056e-17j]]),
#  matrix([[ 0.70710678+0.j ],
#          [-0.5       -0.5j]]),
#  matrix([[ 7.07106781e-01+0.j        ],
#          [-1.29893408e-16-0.70710678j]]),
#  matrix([[0.70710678+0.j ],
#          [0.5       -0.5j]]),
#  matrix([[0.38268343+0.j],
#          [0.92387953+0.j]]),
#  matrix([[0.38268343+0.j        ],
#          [0.65328148+0.65328148j]]),
#  matrix([[3.82683432e-01+0.j        ],
#          [5.65713056e-17+0.92387953j]]),
#  matrix([[ 0.38268343+0.j        ],
#          [-0.65328148+0.65328148j]]),
#  matrix([[ 0.38268343+0.00000000e+00j],
#          [-0.92387953+1.13142611e-16j]]),
#  matrix([[ 0.38268343+0.j        ],
#          [-0.65328148-0.65328148j]]),
#  matrix([[ 3.82683432e-01+0.j        ],
#          [-1.69713917e-16-0.92387953j]]),
#  matrix([[0.38268343+0.j        ],
#          [0.65328148-0.65328148j]]),
#  matrix([[1.+0.j],
#          [0.+0.j]]),
#  matrix([[0.+0.j],
#          [1.+0.j]])]

# #对应的保真度
# [0.9985281367379384, 0.9990919567471859, 0.9970130622032529, 0.9958261601009446, 0.9952238284078838, 0.9957531079642764, 0.9950831555787869, 0.9937914188533712, 0.9917651574449484, 0.9926446441823851, 0.9876565935823789, 0.9865262384614621, 0.9783146366483826, 0.9566958286943457, 0.9391167701117846, 0.9541436487769428, 0.9832260816801249, 0.9899602974099075, 0.9948565032237372, 0.9978374519026485, 0.998901429370501,
#  0.9943256369365048, 0.9979653669858046, 0.9901920927270942, 0.9892809101862989, 0.9928472764689806, 0.9880798626634254, 0.9905812889685016, 0.9904179764917787, 0.990087974947468, 0.9880456154489774, 0.9920021313156344, 0.9932630121865904, 0.9868395876024776, 0.9680604079775859, 0.9430525313278049, 0.913955817960879, 0.8618923217467215,  0.8029979413461314, 0.8053269286429415, 0.9916361446207604, 0.995203431200752,
#  0.9970375835383355, 0.9962825763179544, 0.9961302817347395, 0.991922177570806, 0.9832519916199174, 0.9723729718572476, 0.9751981038405101, 0.9749736825024166, 0.9752860845115607, 0.975148349539015, 0.9797474645786822, 0.9946591102148334, 0.9910632663448915, 0.9868498181836134, 0.9742271459983906,  0.95252337464162, 0.9191977280296351, 0.9148350255091822, 0.9213310363363949, 0.9402266190422941, 0.9857090542253423,
#  0.9859197186188758, 0.9958746583898332, 0.9891550444574094, 0.9807275481116837, 0.9666055402996148, 0.9346810558183347, 0.9128285912634242, 0.9169013006319959, 0.9266809776411367, 0.9543692704182647, 0.9955907074419881, 0.9970928091044657, 0.9964622571371108,  0.994638644455115, 0.9887826030866224, 0.9783546636106615, 0.9712884158296031, 0.9751393366486045, 0.9769088474346244, 0.9735693073208894, 0.9730592111688536,
#  0.9937676273926024, 0.9913519965898672, 0.9831122380223434, 0.9512837026973926, 0.9290987543112664, 0.8867135590581142, 0.8322626314084723, 0.7958825741307194, 0.8659195144968583, 0.9942918752211857, 0.9958440803854672,  0.9978374716101988, 0.9948588234749781, 0.9886713083786718, 0.9917457822170557, 0.9906584010557165, 0.9879311535948092, 0.9915138878255234, 0.9901828000227642, 0.9891243414340886, 0.9903879222325604,
#  0.9879877630899399, 0.9849465441087155, 0.9695690881609693, 0.9439923616109787, 0.9478903606195141, 0.9720567656634505, 0.991519965866841, 0.9938087432541696, 0.9968625424072276,  0.9977343667024143, 0.9986924760677096, 0.9985954305589945, 0.9982528441398146, 0.9960215284563367, 0.9948666378924379, 0.9955510293506391, 0.9950244042078172, 0.9951970616355128, 0.9920927830963493, 0.9930621071793576, 0.991359857558628,
#  0.9921063624582807, 0.9916140761584241]
# 0.9728270302083435

# # #保真度排序
# F_list.sort()# 将列表按顺序排列.
# print(F_list)

# [0.7958825741307194, 0.8029979413461314, 0.8053269286429415, 0.8322626314084723, 0.8618923217467215, 0.8659195144968583, 0.8867135590581142, 0.9128285912634242, 0.913955817960879, 0.9148350255091822, 0.9169013006319959, 0.9191977280296351, 0.9213310363363949, 0.9266809776411367, 0.9290987543112664, 0.9346810558183347, 0.9391167701117846, 0.9402266190422941, 0.9430525313278049, 0.9439923616109787, 0.9478903606195141, 0.9512837026973926, 0.95252337464162, 0.9541436487769428, 0.9543692704182647, 0.9566958286943457, 0.9666055402996148, 0.9680604079775859, 0.9695690881609693, 0.9712884158296031, 0.9720567656634505, 0.9723729718572476, 0.9730592111688536, 0.9735693073208894, 0.9742271459983906, 0.9749736825024166, 0.9751393366486045, 0.975148349539015, 0.9751981038405101, 0.9752860845115607, 0.9769088474346244, 0.9783146366483826, 0.9783546636106615, 0.9797474645786822, 0.9807275481116837, 0.9831122380223434, 0.9832260816801249, 0.9832519916199174, 0.9849465441087155, 0.9857090542253423, 0.9859197186188758, 0.9865262384614621, 0.9868395876024776, 0.9868498181836134, 0.9876565935823789, 0.9879311535948092, 0.9879877630899399, 0.9880456154489774, 0.9880798626634254, 0.9886713083786718, 0.9887826030866224, 0.9891243414340886, 0.9891550444574094, 0.9892809101862989, 0.9899602974099075, 0.990087974947468, 0.9901828000227642, 0.9901920927270942, 0.9903879222325604, 0.9904179764917787, 0.9905812889685016, 0.9906584010557165, 0.9910632663448915, 0.9913519965898672, 0.991359857558628, 0.9915138878255234, 0.991519965866841, 0.9916140761584241, 0.9916361446207604, 0.9917457822170557, 0.9917651574449484, 0.991922177570806, 0.9920021313156344, 0.9920927830963493, 0.9921063624582807, 0.9926446441823851, 0.9928472764689806, 0.9930621071793576, 0.9932630121865904, 0.9937676273926024, 0.9937914188533712, 0.9938087432541696, 0.9942918752211857, 0.9943256369365048, 0.994638644455115, 0.9946591102148334, 0.9948565032237372, 0.9948588234749781, 0.9948666378924379, 0.9950244042078172, 0.9950831555787869, 0.9951970616355128, 0.995203431200752, 0.9952238284078838, 0.9955510293506391, 0.9955907074419881, 0.9957531079642764, 0.9958261601009446, 0.9958440803854672, 0.9958746583898332, 0.9960215284563367, 0.9961302817347395, 0.9962825763179544, 0.9964622571371108, 0.9968625424072276, 0.9970130622032529, 0.9970375835383355, 0.9970928091044657, 0.9977343667024143, 0.9978374519026485, 0.9978374716101988, 0.9979653669858046, 0.9982528441398146, 0.9985281367379384, 0.9985954305589945, 0.9986924760677096, 0.998901429370501, 0.9990919567471859]
