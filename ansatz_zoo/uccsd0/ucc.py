from collections import OrderedDict as ordict
import itertools
import numpy as np
from openfermion.chem import MolecularData
from mindquantum.core import FermionOperator
from mindquantum.core import down_index, up_index, get_fermion_operator, normal_ordered
from mindquantum.algorithm import Transform
from mindquantum.third_party.interaction_operator import InteractionOperator
from mindquantum.core import RX, H, X, RZ, RY
from mindquantum.core import Circuit, TimeEvolution
from mindquantum.core import ParameterResolver as PR


def upccgsd_generator_circuit(mol, k=1, anti_hermitian=True):
    """
    Generate a upccgsd quantum circuit. The ansatz from jctc.8b01004

    Args:
        mol (molecular): A hdf5 molecular file generated by HiQ Fermion.
        th (int, optional): A threadhold of parameters. If a parameter is
            lower than the threadhold, than we will not update it in VQE
            algorithm. Default: 0.
    """
    n_qubits = mol.n_qubits
    n_electrons = mol.n_electrons
    params = {}
    if n_qubits % 2 != 0:
        raise ValueError('The total number of spin-orbitals should be even.')
    single_ops_list = []
    double_ops_list = []
    n_spatial_orbitals = n_qubits // 2

    # Generate excitations
    spin_index_functions = [up_index, down_index]
    # Generate all spin-conserving single and double excitations derived
    # from one spatial occupied-virtual pair
    k_upccgsd_circuit = Circuit()

    for n in range(k):
        single_and_double_ops = FermionOperator()
        op_count = 0
        for i in range(n_spatial_orbitals):
            for a in range(i + 1, n_spatial_orbitals):
                # Get indices of spatial orbitals
                virtual_spatial = a
                occupied_spatial = i

                for spin in range(2):
                    # Get the functions which map a spatial orbital index to a
                    # spin orbital index
                    this_index = spin_index_functions[spin]
                    other_index = spin_index_functions[1 - spin]

                    # Get indices of spin orbitals
                    virtual_this = this_index(virtual_spatial)
                    virtual_other = other_index(virtual_spatial)
                    occupied_this = this_index(occupied_spatial)
                    occupied_other = other_index(occupied_spatial)

                    # Generate single excitations
                    
                    coeff = PR({'k' + str(n) + f'_s{op_count}': 1})
                    params['k' + str(n) + f'_s{op_count}'] = 0.0

                    fermion_ops = FermionOperator(
                        ((occupied_this, 1), (virtual_this, 0)), coeff)

                    if anti_hermitian:
                        fermion_ops += FermionOperator(
                            ((virtual_this, 1), (occupied_this, 0)), -1 * coeff)
                    
                    fermion_ops = normal_ordered(fermion_ops)
                    single_and_double_ops += fermion_ops

                    if n == 0 and fermion_ops not in single_ops_list:
                        single_ops_list.append(fermion_ops)

                    # Generate double excitation
                    coeff = PR({'k' + str(n) + f'_d{op_count}': 1})
                    params['k' + str(n) + f'_d{op_count}'] = 0.0

                    fermion_ops = FermionOperator(
                        ((virtual_this, 1), (occupied_this, 0), (virtual_other, 1),
                        (occupied_other, 0)), coeff)
                    if anti_hermitian:
                        fermion_ops += FermionOperator(
                            ((occupied_other, 1), (virtual_other, 0),
                            (occupied_this, 1), (virtual_this, 0)), -1 * coeff)

                    fermion_ops = normal_ordered(fermion_ops)
                    single_and_double_ops += fermion_ops

                    if n==0 and fermion_ops not in double_ops_list:
                        double_ops_list.append(fermion_ops)

                op_count += 1
        single_and_double_ops = normal_ordered(single_and_double_ops)
        single_and_double_qubit_ops = Transform(single_and_double_ops).jordan_wigner()
        k_upccgsd_circuit += TimeEvolution(single_and_double_qubit_ops.imag, 1.0).circuit

    single_and_double_ops_list = single_ops_list + double_ops_list

    return params, k_upccgsd_circuit


def _transform2pauli(fermion_ansatz):
    """
    Transform a fermion ansatz to pauli ansatz based on jordan-wigner
    transformation.
    """
    out = ordict()
    for i in fermion_ansatz:
        qubit_generator = Transform(i[0]).jordan_wigner()
        if qubit_generator.terms != {}:
            for key, term in qubit_generator.terms.items():
                if key not in out:
                    out[key] = ordict({i[1]: float(term.imag)})
                else:
                    if i[1] in out[key]:
                        out[key][i[1]] += float(term.imag)
                    else:
                        out[key][i[1]] = float(term.imag)
    return out


def _pauli2circuit(pauli_ansatz):
    """Transform a pauli ansatz to parameterized quantum circuit."""
    circuit = Circuit()
    for k, v in pauli_ansatz.items():
        circuit += decompose_single_term_time_evolution(k, v)
    return circuit


def decompose_single_term_time_evolution(term, para):
    """
    Decompose a time evolution gate into basic quantum gates.

    This function only work for the hamiltonian with only single pauli word.
    For example, exp(-i * t * ham), ham can only be a single pauli word, such
    as ham = X0 x Y1 x Z2, and at this time, term will be
    ((0, 'X'), (1, 'Y'), (2, 'Z')). When the evolution time is expressd as
    t = a*x + b*y, para would be {'x':a, 'y':b}.

    Args:
        term (tuple, QubitOperator): the hamiltonian term of just the
            evolution qubit operator.
        para (dict): the parameters of evolution operator.

    Returns:
        Circuit, a quantum circuit.

    Example:
        >>> from mindquantum.ops import QubitOperator
        >>> ham = QubitOperator('X0 Y1')
        >>> circuit = decompose_single_term_time_evolution(ham, {'a':1})
        >>> print(circuit)
        H(0)
        RX(1.571,1)
        X(1 <-: 0)
        RZ(a|1)
        X(1 <-: 0)
        RX(10.996,1)
        H(0)
    """
    if not isinstance(term, tuple):
        try:
            if len(term.terms) != 1:
                raise ValueError("Only work for single term time \
                    evolution operator, but get {}".format(len(term)))
            term = list(term.terms.keys())[0]
        except TypeError:
            raise Exception("Not supported type:{}".format(type(term)))

    out = []
    term = sorted(term)
    rxs = []
    if len(term) == 1:  # single pauli operator
        if term[0][1] == 'X':
            out.append(RX(para).on(term[0][0]))
        elif term[0][1] == 'Y':
            out.append(RY(para).on(term[0][0]))
        else:
            out.append(RZ(para).on(term[0][0]))
    else:
        for index, action in term:
            if action == 'X':
                out.append(H.on(index))
            elif action == 'Y':
                rxs.append(len(out))
                out.append(RX(np.pi / 2).on(index))

        for i in range(len(term) - 1):
            out.append(X.on(term[i + 1][0], term[i][0]))
        out.append(RZ({i: 2 * j for i, j in para.items()}).on(term[-1][0]))
        for i in range(len(out) - 1)[::-1]:
            if i in rxs:
                out.append(RX(np.pi * 3.5).on(out[i].obj_qubits))
            else:
                out.append(out[i])
    return Circuit(out)


def generate_upccgsd(molecular, k=1):
    """
    Generate a uccsd quantum circuit based on a molecular data generated by
    HiQfermion or openfermion.

    Args:
        molecular (Union[str, MolecularData]): the name of the molecular data file,
            or openfermion MolecularData.
        th (int): the threshold to filt the uccsd amplitude. When th < 0, we
            will keep all amplitudes. When th == 0, we will keep all amplitude
            that are positive.

    Returns:
        - **uccsd_circuit** (Circuit), the ansatz circuit generated by uccsd method.
        - **single_and_double_ops_list** (numpy.ndarray), all single and double operators used in 1-upccgsd ansatz.
        - **parameters_name** (list[str]), the name of initial parameters.
        - **qubit_hamiltonian** (QubitOperator), the hamiltonian of the molecule.
        - **n_qubits** (int), the number of qubits in simulation.
        - **n_electrons**, the number of electrons of the molecule.
    """
    if isinstance(molecular, str):
        mol = MolecularData(filename=molecular)
        mol.load()
    else:
        mol = molecular
    parameters, k_upccgsd_circuit = upccgsd_generator_circuit(mol, k)

    ham_of = mol.get_molecular_hamiltonian()
    inter_ops = InteractionOperator(*ham_of.n_body_tensors.values())
    ham_hiq = get_fermion_operator(inter_ops)
    qubit_hamiltonian = Transform(ham_hiq).jordan_wigner()
    qubit_hamiltonian.compress()

    parameters_name = list(parameters.keys())
    return k_upccgsd_circuit, \
        parameters_name, \
        qubit_hamiltonian, \
        mol.n_qubits, \
        mol.n_electrons